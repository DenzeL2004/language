# Стандарт представления синтаксических деревьев

## Цели стандарта
Создателями стандарта ставится цель создания унифицированного формата текстового представления синтаксических деревьев, генерируемых front-end-компиляторами при распознавании файлов программ на различных высокоуровневых языках.

## Список используемых сокращений
В тексте стандарта используются следующие сокращения
- ЯВУ - язык программирования высокого уровня

## Поставленные задачи
Создаваемые ЯВУ должны уметь решать каждую из нижеприведённых задач:
- Вычисление факториала небольшого (не превышающего 12) целого числа при помощи рекурсивного алгоритма.
- Нахождение действительных корней квадратного трёхчлена.
- Вывод изображения при помощи записи в видеопамять

## Требования к стандарту
При создании стандарта были выдвинуты следующие требования:

1. **Универсальность**. Программа, написанная написанная на целевом ЯВУ должна быть корректно представима в формате, регламентируемом стандартом.
2. **Ориентированность на задачу**. Стандарт должен учитывать специфику проблем, решаемых при помощи программ на целевых ЯВУ.
3. **Простота в реализации**. Стандарт должен быть достаточно естественным, чтобы создатели компиляторов для целевых ЯВУ не испытывали чрезмерных сложностей при следовании ему.

## Общие положения стандарта
- Синтаксические деревья представляются в виде текстового файла, использующего кодировку ASCII.
- Символы, не входящие в набор ASCII являются недопустимыми.
- Пробельные символы, не находящиеся внутри лексемы, являются незначимыми и игнорируются.
- Числа могут записываться как в формате с десятичной точкой, так и без неё. При записи в формате с десятичной точкой после неё может быть указано не более трёх десятичных разрядов.

## Формат записи узла дерева
Каждый узел дерева записывается в фигурных скобках ('{' и '}'). Внутри фигурных скобок через запятую записываются тип узла, хранимое значение, левый дочерний узел, правый дочерний узел. Пустой узел обозначается пустой парой фигурных скобок ("{ }").

Если правый дочерний узел пуст, пустым обязан быть и левый дочерний узел (т.е. если узел унарный, то его единственный ребёнок - правый).

Далее приведено формальное описание грамматики записи синтаксического дерева.
```ebnf
G    ::= Node '\0'
Node ::= ('{' _ '}') | ('{' _ Type _ ',' _ ',' Val _ ',' _ Node _ ',' _ Node _ '}')
_    ::= [' ', '\n', '\t', '\v', '\f', '\r']*
Type ::= "NUM" | "VAR" | "OP" | "CALL"| "ARG" | "SEQ" |
         "IF" | "WHILE" | "BLOCK" | "NVAR" | "DEF" | "PAR"
Val  ::= Num | Name | Op | ""
Num  ::= [0-9]+ ('.'[0-9]? [0-9]? [0-9]? )?
Name ::= [A-Za-z_]+ [A-Za-z0-9_]*
Op   ::= "ADD" | "SUB" | "MUL" | "DIV" |
         "AND" | "OR"  | "NOT" | "ASS
```

## Типы узлов

### Число `NUM`
Дробное число с фиксированной точностью в формате с десятичной запятой или без неё.

- **Значение:** Число
- **Дочерние узлы:** Оба дочерних узла пусты

### Переменная `VAR`
Объявленная ранее переменная.

- **Значение:** Имя переменной
- **Дочерние узлы:** Оба дочерних узла пусты

К моменту вхождения узла `VAR` с некоторым именем переменной в рассмотрение, в дереве должен уже быть рассмотрен узел `NVAR` с тем же именем.

### Оператор `OP`
Унарный либо бинарный оператор

- **Значение:** Тип оператора (см. раздел [Типы операторов](#типы-операторов))
- **Дочерние узлы:** Операнды. Конкретный тип оператора может выдвигать свои требования к количеству и типам дочерних узлов.

### Вызов функции `CALL`
Вызов функции по её имени с передачей ей аргументов.

- **Значение:** Имя функции
- **Дочерние узлы:** Левый дочерний узел всегда пуст. Правый дочерний узел обязан иметь тип `NUM`, `VAR`, `OP` или `ARG`.

Правый дочерний узел вычисляется до непосредственного вызова функции.

### Список аргументов `ARG`
Список фактических параметров (аргументов) при вызове функции.

- **Значение:** Пустое
- **Дочерние узлы:** Левый дочерний узел - `NUM`, `VAR` или `OP`. Правый дочерний узел - `NUM`, `VAR`, `OP` или `ARG`

Узел такого типа гарантирует вычисление левого дочернего узла перед вычислением правого.